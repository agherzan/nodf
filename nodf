#!/usr/bin/env python

#
# ** The MIT License **
#
# Copyright (c) 2013 Andrei Gherzan
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
#
DESCRIPTION = "A utility to be used for managing dotfiles... and not only."
#
# Home: https://github.com/agherzan/nodf
#
# Author: Andrei Gherzan <andrei@gherzan.ro>
#

# Default variables
REPO = '~/dotfilesrepo'
PATH = '~/dotfilespath'
BACKUPEXT = 'bak'

try:
    import os
    import git
    import argparse
    import sys
    import difflib
    import time
    from argparse import ArgumentParser
    import logging
    from colorlogging import ColoredFormatter
except:
    print "ERROR : Can't load at least one module. Please follow README first."
    sys.exit(1)

def getInput(valids = [], log = None):
    '''
    Return a valid user option
    '''
    if not valids:
        return
    sys.stdout.write("Selection: ")
    s = raw_input()
    while not s in valids:
        s = raw_input("Wrong selection [" + '|'.join(valids)  + "]: ")
    return s

def RepoExists(repo):
    '''
    Check if a path contains a repository
    '''
    if os.path.isdir(repo + '/.git'):
        return True
    return False

def clonefunc(args, log):
    '''
    Command clones a repository in 'repo'
    This path can be configured at runtime or defaults to REPO.
    '''
    log.info("git clone %s in %s ." %(args.repository, args.repo))
    if RepoExists(args.repo):
        log.warning("There is already a repository in %s ." % args.repo)
        return True
    if not args.dryrun:
        if not os.path.isdir(args.repo):
            try:
                os.makedirs(args.repo)
            except:
                log.error("The path %s doesn't exist and cannot be created." % args.repo)
                return False
        try:
            git.cmd.Git(args.repo).clone(args.repository, args.repo)
        except Exception as e:
            log.error("Can't clone in %s." % args.repo)
            return False
    else:
        log.debug("Not actually cloning, just dry run.")
    return True

def pullfunc(args, log):
    '''
    Pull repository for remote changes (example have the same repository on
    multiple machines).
    '''
    if not RepoExists(args.repo):
        log.error("There is no %s repository." % args.repo)
        return False
    log.info("git pull in %s." % args.repo)
    g = git.cmd.Git(args.repo)
    if not args.dryrun:
        g.pull()
    else:
        log.debug("Not actually pulling, just dry run.")
    return True

def listfunc(args, log):
    '''
    List remote in the repository
    '''
    try:
        g = git.cmd.Git(args.repo)
        remote = g.config('remote.origin.url')
    except:
        log.warn("No origin remote found in %s repository." % args.repo)
        return False
    log.info("%s cloned from [%s]." % (args.repo, remote))
    return True

def statusfunc(args, log):
    '''
    Git status in the repository
    '''
    if not RepoExists(args.repo):
        log.error("There is no %s repository." % args.repo)
        return False
    g = git.cmd.Git(args.repo)
    log.info("%s" % g.status())
    return True

def trackfunc(args, log):
    log.warn("Command not implemented yet.")
    return True

def symlinkfunc(args, log):
    '''
    Go through all files in repo and create corespondent symlinks in path
    '''
    if not RepoExists(args.repo):
        log.error("There is no %s repository." % args.repo)
        return False
    log.debug("Symlink command on %s repository." % args.repo)
    if not os.path.exists(args.repo):
        log.error("There is no %s repository." % args.repo)
        sys.exit(1)
    for root, dirs, files in os.walk(args.repo):
        # Don't go in .git - obviously
        if '.git' in dirs:
            dirs.remove('.git')
        for file in files:
            source = root + '/' + file
            sourcerepo = os.path.relpath(source, args.repo) # source relative to repo
            name = args.path + "/" + sourcerepo
            log.debug('Symlinking %s -> %s.' % (source, name))
            if os.path.exists(name):
                if os.path.realpath(name) == source:
                    log.warning('%s already symlinked.' % file)
                    continue
                log.warning('Conflict %s already exists. [A]bort [S]kip [D]iff [F]ix Fix[B]utBackup ? ' % file)
                selection = getInput(['A', 'S', 'D', 'F', 'B'], log)
                while selection == 'D':
                    sourcedate = time.ctime(os.stat(source).st_mtime)
                    namedate = time.ctime(os.stat(name).st_mtime)
                    sourcelines = open(source, 'U').readlines()
                    namelines = open(name, 'U').readlines()
                    #diff = difflib.context_diff(sourcelines, namelines, source, name,
                    #                        sourcedate, namedate, n=3)
                    diff = difflib.ndiff(sourcelines, namelines)
                    sys.stdout.writelines(diff)
                    selection = getInput(['A', 'S', 'D', 'F', 'B'], log)
                if selection == 'A':
                    return True
                elif selection == 'S':
                    continue
                elif selection == 'F':
                    try:
                        if not args.dryrun:
                            os.remove(name)
                    except:
                        log.error("Can't remove %s .")
                        continue
                elif selection == 'B':
                    try:
                        if not args.dryrun:
                            os.rename(name, name + '.' + args.backupext)
                    except:
                        log.error("Can't rename %s to %s.%s .", name, name, backupext)
                        continue
            if not os.path.exists(os.path.dirname(name)):
                if not args.dryrun:
                    os.makedirs(os.path.dirname(name))
            log.info('Symlinking %s .' % file)
            if not args.dryrun:
                os.symlink(source, name)
    return True

def main():
    '''
    Main
    '''
    # Parse arguments
    parser = ArgumentParser(add_help=False, version = '1.0a', description=DESCRIPTION)
    parser.add_argument('-h', '--help', action='help',
                      help = 'Print this message and exit')
    parser.add_argument('-d', '--debug', action="store_true", dest = 'debug', default = False,
                      help = 'Run in debug mode')
    parser.add_argument('-r', '--repo', default = REPO, dest = 'repo',
                      help = 'Repo directory to be used. Default: ' + REPO)
    parser.add_argument('-p' , '--path', default = PATH,
                      help = 'Root path of the files to be where we create symlinks. Default : ' + PATH)
    parser.add_argument('--dry-run', action = 'store_true', dest = 'dryrun', default = False,
                      help = "Don't actually run command")
    parser.add_argument('-n', '--no-colors', action = 'store_false', dest = 'colors', default = True,
                      help = "Don't actually run command")
    parser.add_argument('-b', '--backup-ext', default = BACKUPEXT, dest = 'backupext',
                      help = 'Extension to be used when backup conflicting files. Default: ' + BACKUPEXT)
    # Commands
    subparsers = parser.add_subparsers(title = 'Commands',
        description = 'Commands to manipulate files. \
                       Run comand -h to see help for each command.')
    clone = subparsers.add_parser('clone', help='Clone repository')
    clone.add_argument('repository', help='Repository to be cloned')
    clone.set_defaults(func=clonefunc)
    pull = subparsers.add_parser('pull', help='Pull repository')
    pull.set_defaults(func=pullfunc)
    list = subparsers.add_parser('list', help='List repository')
    list.set_defaults(func=listfunc)
    status = subparsers.add_parser('status', help='Check repository status')
    status.set_defaults(func=statusfunc)
    track = subparsers.add_parser('track', help='Track files')
    track.add_argument('files', help='Files to be tracked')
    track.set_defaults(func=trackfunc)
    symlink = subparsers.add_parser('symlink', help='Symlink repository')
    symlink.set_defaults(func=symlinkfunc)

    args = parser.parse_args()

    # Logger
    log = logging.getLogger()
    log.setLevel(logging.INFO)
    ch = logging.StreamHandler()
    ch.setFormatter(ColoredFormatter(args.colors))
    log.addHandler(ch)

    # Expand paths
    args.path = os.path.normpath(os.path.expanduser(args.path))
    args.repo = os.path.normpath(os.path.expanduser(args.repo))

    if args.debug:
        log.setLevel(logging.DEBUG)
        log.debug("Running in debug/verbose mode.")

    if not args.func(args, log):
        log.debug("Return exit code 1 as command failed.")
        sys.exit(1)

if __name__ == "__main__":
    main()
