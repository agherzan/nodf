#!/usr/bin/env python

#
# ** The MIT License **
#
# Copyright (c) 2013 Andrei Gherzan
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
#
DESCRIPTION = "A utility to be used for managing dotfiles... and not only."
#
# Home: https://github.com/agherzan/nodf
#
# Author: Andrei Gherzan <andrei@gherzan.ro>
#

# Default variables
REPOSITORY = '~/dotfiles'
BACKUPEXT = 'bak'
HOME = '~'

try:
    import os
    import git
    import argparse
    import sys
    import difflib
    import time
    from argparse import ArgumentParser
    import logging
    from colorlogging import ColoredFormatter
except:
    print "ERROR : Can't load at least one module. Please follow README first."
    sys.exit(1)

def getInput(valids = [], log = None):
    '''
    Return a valid user option
    '''
    if not valids:
        return
    sys.stdout.write("Selection: ")
    s = raw_input()
    while not s in valids:
        s = raw_input("Wrong selection [" + '|'.join(valids)  + "]: ")
    return s

def ResolveConflict(source, destination, args, log):
    '''
    Resolve conflict between 2 files interactively

    Return
        * False if file1 should not be copied in file2
        * True otherwise.
    '''
    # If both files are the same no need to do anything
    if os.path.realpath(destination) == os.path.realpath(source):
        log.debug('%s already symlinked.' % source)
        return False

    log.warning('Conflict %s already exists.' % source)
    log.warning('[A]bort [S]kip [D]iff [F]ix Fix[B]utBackup ? ')

    # Diff option
    selection = getInput(['A', 'S', 'D', 'F', 'B'], log)
    while selection == 'D':
        sourcelines = open(source, 'U').readlines()
        destinationlines = open(destination, 'U').readlines()
        '''sourcedate = time.ctime(os.stat(source).st_mtime)
        namedate = time.ctime(os.stat(name).st_mtime)
        diff = difflib.context_diff(sourcelines, namelines, source, name,
                               sourcedate, namedate, n=3)'''
        diff = difflib.ndiff(sourcelines, destinationlines)
        sys.stdout.writelines(diff)
        selection = getInput(['A', 'S', 'D', 'F', 'B'], log)

    # Other options
    if selection == 'A':
        sys.exit(0)
    elif selection == 'S':
        return False
    elif selection == 'F':
        try:
            if not args.dryrun:
                os.remove(destination)
        except:
            log.error("Can't remove %s .")
            return False
    elif selection == 'B':
        try:
            if not args.dryrun:
                os.rename(destination, destination + '.' + args.backupext)
        except:
            log.error("Can't rename %s to %s.%s .", destination, destination, args.backupext)
            return False

    return True

def RepoExists(repo):
    '''
    Check if a path contains a repository
    '''
    if os.path.isdir(repo + '/.git'):
        return True
    return False

def clonefunc(args, log):
    '''
    Command clones a repository in 'repo'
    This path can be configured at runtime or defaults to REPOSITORY.
    '''
    log.info("git clone %s in %s ." %(args.repository, args.repo))
    if RepoExists(args.repo):
        log.warning("There is already a repository in %s ." % args.repo)
        return True
    if not args.dryrun:
        if not os.path.isdir(args.repo):
            try:
                os.makedirs(args.repo)
            except:
                log.error("The path %s doesn't exist and cannot be created." % args.repo)
                return False
        try:
            git.cmd.Git(args.repo).clone(args.repository, args.repo)
        except Exception as e:
            log.error("Can't clone in %s." % args.repo)
            return False
    else:
        log.debug("Not actually cloning, just dry run.")
    return True

def pullfunc(args, log):
    '''
    Pull repository for remote changes (example have the same repository on
    multiple machines).
    '''
    if not RepoExists(args.repo):
        log.error("There is no %s repository." % args.repo)
        return False
    log.info("git pull in %s ." % args.repo)
    if not args.dryrun:
        try:
            g = git.cmd.Git(args.repo)
            g.pull()
        except:
            log.error("Can't pull in %s ." % args.repo)
            return False
    else:
        log.debug("Not actually pulling, just dry run.")
    return True

def listfunc(args, log):
    '''
    List remote in the repository
    '''
    try:
        g = git.cmd.Git(args.repo)
        remote = g.config('remote.origin.url')
    except:
        log.warn("No origin remote found in %s repository." % args.repo)
        return False
    log.info("%s cloned from [%s]." % (args.repo, remote))
    return True

def statusfunc(args, log):
    '''
    Git status in the repository
    '''
    if not RepoExists(args.repo):
        log.error("There is no %s repository." % args.repo)
        return False
    g = git.cmd.Git(args.repo)
    log.info("%s" % g.status())
    return True

def trackfunc(args, log):
    '''
    Track one ore more file in repository
    Copy all files in repository and create symlinks to new files
    '''
    for file in args.files:
        # Arbsolute and clean path to file
        file = os.path.abspath(os.path.normpath(os.path.expanduser(file)))

        if not os.path.isfile(file):
            log.warn("File %s does not exist." % file)
            continue

        repofile = args.repo + '/' + os.path.relpath(file, args.home)
        repofile = os.path.abspath(os.path.normpath(repofile))
        if not args.home in repofile:
            log.warn("File %s not in home directory." % file)
            continue

        log.info('Tracking %s in %s.' %(file, args.repo))

        if os.path.exists(repofile):
            if ResolveConflict(file, repofile, args, log) == False:
                continue

        if not args.dryrun:
                try:
                    os.renames(file, repofile)
                    if not os.path.exists(os.path.dirname(file)):
                        os.makedirs(os.path.dirname(file))
                    os.symlink(repofile, file)
                except Exception as e:
                    log.error("Can't track %s ." % (file))
                    continue
    return True

def symlinkfunc(args, log):
    '''
    Go through all files in repo and create corespondent symlinks in path
    '''
    if not RepoExists(args.repo):
        log.error("There is no %s repository." % args.repo)
        return False
    log.debug("Symlink command on %s repository." % args.repo)
    if not os.path.exists(args.repo):
        log.error("There is no %s repository." % args.repo)
        sys.exit(1)
    for root, dirs, files in os.walk(args.repo):
        # Don't go in .git - obviously
        if '.git' in dirs:
            dirs.remove('.git')
        for file in files:
            source = root + '/' + file
            sourcerepo = os.path.relpath(source, args.repo) # source relative to repo
            name = args.home + '/' + sourcerepo
            log.debug('Symlinking %s -> %s.' % (source, name))
            if os.path.exists(name):
                if ResolveConflict(source, name, args, log) == False:
                    continue
            log.info('Symlinking %s .' % file)
            if not os.path.exists(os.path.dirname(name)):
                if not args.dryrun:
                    try:
                        os.makedirs(os.path.dirname(name))
                    except:
                        log.error("Can't create symlink in %s ." % name)
                        continue
            if not args.dryrun:
                try:
                    os.symlink(source, name)
                except:
                    log.error("Can't create symlink in %s ." % name)
    return True

def initfunc(args, log):
    '''
    Init repository in user defined repo path or in default one
    '''
    if os.path.exists(args.repo):
        if os.listdir(args.repo):
            log.error("Repository path %s already exists and is not empty." % args.repo)
            return False
    else:
        if not args.dryrun:
            os.mkdir(args.repo)

    log.info("Initializing repository in %s ." % args.repo)
    try:
        if not args.dryrun:
            g = git.cmd.Git(args.repo)
            g.init()
    except:
        log.error("Can't init repository in %s ." % args.repo)

def main():
    '''
    Main
    '''
    # Parse arguments
    parser = ArgumentParser(add_help=False, version = '1.0a', description=DESCRIPTION)
    parser.add_argument('-h', '--help', action='help',
                      help = 'Print this message and exit')
    parser.add_argument('-d', '--debug', action="store_true", dest = 'debug', default = False,
                      help = 'Run in debug mode')
    parser.add_argument('-r', '--repo', default = REPOSITORY, dest = 'repo',
                      help = 'Repo directory to be used. Default: ' + REPOSITORY)
    parser.add_argument('--dry-run', action = 'store_true', dest = 'dryrun', default = False,
                      help = "Don't actually run command")
    parser.add_argument('-n', '--no-colors', action = 'store_false', dest = 'colors', default = True,
                      help = "Don't use any colors")
    # Commands
    subparsers = parser.add_subparsers(title = 'Commands',
        description = 'Commands to manipulate files. \
                       Run comand -h to see help for each command.')
    clone = subparsers.add_parser('clone', help='Clone repository')
    clone.add_argument('repository', help='Repository to be cloned')
    clone.set_defaults(func=clonefunc)
    pull = subparsers.add_parser('pull', help='Pull repository')
    pull.set_defaults(func=pullfunc)
    list = subparsers.add_parser('list', help='List repository')
    list.set_defaults(func=listfunc)
    status = subparsers.add_parser('status', help='Check repository status')
    status.set_defaults(func=statusfunc)
    track = subparsers.add_parser('track', help='Track files')
    track.add_argument('files', nargs='+', help='Files to be tracked')
    track.add_argument('-b', '--backup-ext', default = BACKUPEXT, dest = 'backupext',
                      help = 'Extension to be used when backup conflicting files. Default: ' + BACKUPEXT)
    track.set_defaults(func=trackfunc)
    symlink = subparsers.add_parser('symlink', help='Symlink repository')
    symlink.add_argument('-b', '--backup-ext', default = BACKUPEXT, dest = 'backupext',
                      help = 'Extension to be used when backup conflicting files. Default: ' + BACKUPEXT)
    symlink.set_defaults(func=symlinkfunc)
    init = subparsers.add_parser('init', help='Init repository')
    init.set_defaults(func=initfunc)

    args = parser.parse_args()

    # Logger
    log = logging.getLogger()
    log.setLevel(logging.INFO)
    ch = logging.StreamHandler()
    ch.setFormatter(ColoredFormatter(args.colors))
    log.addHandler(ch)

    # Expand paths
    args.repo = os.path.normpath(os.path.expanduser(args.repo))
    args.home = os.path.normpath(os.path.expanduser(HOME))

    if args.debug:
        log.setLevel(logging.DEBUG)
        log.debug("Running in debug/verbose mode.")

    if not args.func(args, log):
        log.debug("Return exit code 1 as command failed.")
        sys.exit(1)

if __name__ == "__main__":
    main()
